<script defer src="https://use.fontawesome.com/releases/v5.0.7/js/all.js"></script>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
<script src="anime.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha512-z4OUqw38qNLpn1libAN9BsoDx6nbNFio5lA6CuTp9NlK83b89hgyCVq+N5FdBJptINztxn1Z3SaKSKUS5UP60Q==" crossorigin="anonymous"></script>
         <!--Scrolling Effect--> 
<script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script>
AOS.init({

    offset: 100, // offset (in px) from the original trigger point
    delay: 0, // values from 0 to 3000, with step 50ms
    duration: 600, // values from 0 to 3000, with step 50ms
});
</script>
<script>
    function fitElementToParent(el, padding) {
  var timeout = null;
  function resize() {
    if (timeout) clearTimeout(timeout);
    anime.set(el, {scale: 1});
    var pad = padding || 0;
    var parentEl = el.parentNode;
    var elOffsetWidth = el.offsetWidth - pad;
    var parentOffsetWidth = parentEl.offsetWidth;
    var ratio = parentOffsetWidth / elOffsetWidth;
    timeout = setTimeout(anime.set(el, {scale: ratio}), 10);
  }
  resize();
  window.addEventListener('resize', resize);
}

var sphereAnimation = (function() {

  var sphereEl = document.querySelector('.sphere-animation');
  var spherePathEls = sphereEl.querySelectorAll('.sphere path');
  var pathLength = spherePathEls.length;
  var hasStarted = false;
  var aimations = [];

  fitElementToParent(sphereEl);

  var breathAnimation = anime({
    begin: function() {
      for (var i = 0; i < pathLength; i++) {
        aimations.push(anime({
          targets: spherePathEls[i],
          stroke: {value: ['rgba(255,75,75,1)', 'rgba(80,80,80,.35)'], duration: 500},
          translateX: [2, -4],
          translateY: [2, -4],
          easing: 'easeOutQuad',
          autoplay: false
        }));
      }
    },
    update: function(ins) {
      aimations.forEach(function(animation, i) {
        var percent = (1 - Math.sin((i * .35) + (.0022 * ins.currentTime))) / 2;
        animation.seek(animation.duration * percent);
      });
    },
    duration: Infinity,
    autoplay: false
  });

  var introAnimation = anime.timeline({
    autoplay: false
  })
  .add({
    targets: spherePathEls,
    strokeDashoffset: {
      value: [anime.setDashoffset, 0],
      duration: 3900,
      easing: 'easeInOutCirc',
      delay: anime.stagger(190, {direction: 'reverse'})
    },
    duration: 2000,
    delay: anime.stagger(60, {direction: 'reverse'}),
    easing: 'linear'
  }, 0);

  var shadowAnimation = anime({
      targets: '#sphereGradient',
      x1: '25%',
      x2: '25%',
      y1: '0%',
      y2: '75%',
      duration: 30000,
      easing: 'easeOutQuint',
      autoplay: false
    }, 0);

  function init() {
    introAnimation.play();
    breathAnimation.play();
    shadowAnimation.play();
  }
  
  init();

})();
</script>
<script>
    document.addEventListener('DOMContentLoaded',function(event){
  // array with texts to type in typewriter
  var dataText = [  "B.Tech InfoTech.", "Web-Developer.", "Overthinker." , "Hi , I am Arjav !",];
  
  // type one text in the typwriter
  // keeps calling itself until the text is finished
  function typeWriter(text, i, fnCallback) {
    // chekc if text isn't finished yet
    if (i < (text.length)) {
      // add next character to h1
     document.querySelector("h1").innerHTML = text.substring(0, i+1) +'<span aria-hidden="true"></span>';

      // wait for a while and call this function again for next character
      setTimeout(function() {
        typeWriter(text, i + 1, fnCallback)
      }, 200);
    }
    // text finished, call callback if there is a callback function
    else if (typeof fnCallback == 'function') {
      // call callback after timeout
      setTimeout(fnCallback, 700);
    }
  }
  // start a typewriter animation for a text in the dataText array
   function StartTextAnimation(i) {
     if (typeof dataText[i] == 'undefined'){
        setTimeout(function() {
          StartTextAnimation(0);
        }, 20000);
     }
     // check if dataText[i] exists
    if (i < dataText[i].length) {
      // text exists! start typewriter animation
     typeWriter(dataText[i], 0, function(){
       // after callback (and whole text has been animated), start next text
       StartTextAnimation(i + 1);
     });
    }
  }
  // start the text animation
  StartTextAnimation(0);
});
</script>
<script>
  const staggerVisualizerEl = document.querySelector('.stagger-visualizer');
  const fragment = document.createDocumentFragment();
  const numberOfElements = 81;

  for (let i = 0; i < numberOfElements; i++) {
    fragment.appendChild(document.createElement('div'));
  }

  staggerVisualizerEl.appendChild(fragment);

  const staggersAnimation = anime.timeline({
    targets: '.stagger-visualizer div',
    easing: 'easeInOutSine',
    delay: anime.stagger(50),
    loop: true,
    autoplay: false,
    duration: 600,
    loopComplete: (a) => console.log('end'),
    //update: () => console.log(staggersAnimation.progress)
  })
  .add({
    scale: anime.stagger([2.5, 1], {from: 'center', grid: [9, 9]}),
    translateX: anime.stagger([-100, 100]),
    rotate: anime.stagger([-45, 45]),
    easing: 'easeInOutCirc',
    delay: anime.stagger(10, {from: 'center'})
  })
  .add({
    scale: anime.stagger([2.5, 1], {from: 'center', easing: 'easeInOutCirc'}),
    translateX: anime.stagger([-200, 200]),
    translateY: anime.stagger([-200, 200]),
    rotate: 0,
    delay: anime.stagger(1, {from: 'last'})
  })
  .add({
    rotate: anime.stagger(2, {from: 'center', direction: 'reverse', easing: 'easeInSine'}),
    translateX: 0,
    translateY: 0,
    delay: anime.stagger(10, {from: 'center'})
  })
  .add({
    scale: anime.stagger([2, 1], {grid: [9, 9], axis: 'y'}),
    translateY: anime.stagger([-100, 200], {grid: [9, 9], axis: 'y'}),
    rotate: 0,
    delay: anime.stagger(1, {from: 'last'})
  })
  .add({
    translateX: () => anime.random(-100, 100),
    translateY: () => anime.random(-100, 100),
    scale: anime.stagger([1.5, .5], {from: 'center'}),
    rotate: anime.stagger([10, -10], {from: 'last'}),
    delay: anime.stagger(50, {from: 'center', grid: [9, 9]}),
  })
  .add({
    translateX: () => anime.random(-100, 100),
    translateY: () => anime.random(-100, 100),
    rotate: anime.stagger([-10, 10], {from: 'last'}),
    scale: 1,
    delay: anime.stagger(50, {from: 'center', grid: [9, 9]}),
  })
  .add({
    translateX: 0,
    translateY: anime.stagger(6, {from: 'center', direction: 'reverse'}),
    rotate: 0,
    delay: anime.stagger(50, {from: 'center', grid: [9, 9]}),
  })
  .add({
    translateX: anime.stagger('1rem', {grid: [9, 9], from: 'center', axis: 'x'}),
    //translateY: anime.stagger('1rem', {grid: [9, 9], from: 'center', axis: 'y'}),
    delay: anime.stagger(200, {grid: [9, 9], from: 'center', direction: 'reverse'})
  })
  .add({
    translateX: anime.stagger([25, -25], {from: 'first'}),
    translateY: 0,
    rotate: anime.stagger([40, -40], {from: 'first'}),
    delay: anime.stagger(10, {from: 'first'}),
  })
  .add({
    translateY: anime.stagger([-240, 240]),
    rotate: () => anime.random(-100, 100),
    scale: anime.stagger([1, 3], {from: 'center'}),
    delay: anime.stagger(10, {from: 0}),
  })
  .add({
    translateX: 0,
    translateY: 0,
    scale: 1,
    rotate: 360,
    duration: 2000,
    delay: 0,
  });

  staggersAnimation.play();
</script>
</body>
</html>
